
__all__ = ["rx_debounce"]

def rx_timer(
    time_period_seconds: float,
    initial_delay: Optional[float] = 0,
    coro_func: Optional[FunctionProducer] = None,
) -> Observable:
    """Emit value with a period of time_period_seconds after an initial delay.

    Value will be produced by coro_func or are just boolean True.

    # Parameters
    time_period_seconds (float): minimum period of time
    initial_delay (float): initial delay before produce value (default: {0})
    coro_func (FunctionProducer): producer of value (default: {None})

    # Returns
    (Observable): an observable instance
    """
    from curio import time, spawn, TaskCancelled

    _subject = subject()
    _run = False  # TODO test without _run 'cause we use cancel
    _task = None

    _producer = coro_func if coro_func else lambda: True

    async def _tick():
        nonlocal _subject, _run
        try:
            await time.sleep(initial_delay)
            while _run:
                start = time.time()
                await _subject.on_next(await _producer())
                duration = time.time() - start

                # adjust wait time
                time_shift = time_period_seconds - duration
                if time_shift > 0:
                    await time.sleep(time_shift)

        except TaskCancelled:
            pass

    async def _on_connect():
        nonlocal _run, _task
        if _task is None:
            _run = True
            _task = await spawn(corofunc=_tick, daemon=True, allow_cancel=True)

    async def _on_disconnect():
        nonlocal _run, _task
        if _task:
            _run = False
            await _task.cancel(blocking=True)
            await _subject.on_completed()
            _task = None

    return multicast(
        an_observable=_subject, on_connect=_on_connect, on_disconnect=_on_disconnect
    ).ref_count()

